\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{silence}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{newunicodechar}
\usepackage{etoolbox}
\usepackage[margin=1.2in]{geometry}
\usepackage{stmaryrd}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
% https://tex.stackexchange.com/a/106719
\DeclareSymbolFont{sfletters}{OML}{cmbrm}{m}{it}
\DeclareMathSymbol{\slambda}{\mathord}{sfletters}{"15}
%https://tex.stackexchange.com/a/335857
\usepackage{microtype}
\usepackage[dvipsnames]{xcolor}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{cleveref}

\title{Polymorphic algebraic effects: theoretical properties and implementation}
\author{Wiktor Kuchta}
\date{\vspace{-4ex}}

%\newcommand{\textbsf}[1]{\textbf{\textsf{#1}}}
%\newunicodechar{λ}{\mathsf{\lambda}}
%\newunicodechar{λ}{\mathbf{\lambda}}
%\newunicodechar{λ}{\boldsymbol{\lambda}}
%\newunicodechar{λ}{\lambda}
\newunicodechar{λ}{\slambda}
\newcommand{\Do}{\textsf{do\;}}
\newcommand{\Handle}{\textsf{handle\;}}
\newcommand{\Lift}[1]{\boldsymbol{[}#1\boldsymbol{]}}
\newcommand{\subst}[2]{\{#1/#2\}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\K}{\mathcal{K}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\kT}{\mathsf{T}}
\newcommand{\kE}{\mathsf{E}}
\newcommand{\kR}{\mathsf{R}}
\newcommand{\Free}{\textrm{-}\mathrm{free}}
\newcommand{\Obs}{\mathrm{Obs}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\modulus}[1]{\left| #1 \right|}
\newcommand{\abs}{\modulus}
\newcommand{\ol}{\overline}
\DeclareMathOperator{\dom}{dom}
\newcommand{\+}{\enspace}
\newcommand{\gr}{\textcolor{ForestGreen}}

\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}

\newunicodechar{│}{\mid} % Digr vv
%\newunicodechar{╱}{/} % Digr FD
\newunicodechar{╱}{\mathbin{/}} % Digr FD
\newunicodechar{∷}{::} % Digr ::
\newunicodechar{□}{\square} % Digr OS
\newunicodechar{∅}{\emptyset} % Digr /0
\newunicodechar{∞}{\infty} % Digr 00
\newunicodechar{∂}{\partial} % Digr dP
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{ξ}{\xi} % Digr c*
\newunicodechar{δ}{\delta} % Digr d*
\newunicodechar{ε}{\varepsilon}
\newunicodechar{φ}{\varphi}
\newunicodechar{γ}{\gamma} % Digr g*
\newunicodechar{θ}{\theta} % Digr h*
\newunicodechar{ι}{\iota} % Digr i*
\newunicodechar{κ}{\kappa}
\newunicodechar{μ}{\mu}
\newunicodechar{ν}{\nu}
\newunicodechar{π}{\pi}
\newunicodechar{ψ}{\psi}
\newunicodechar{ρ}{\rho}
\newunicodechar{σ}{\sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{ω}{\omega}
\newunicodechar{η}{\eta} % Digr y*
\newunicodechar{ζ}{\zeta} % Digr z*
\newunicodechar{Δ}{\Delta}
\newunicodechar{Γ}{\Gamma}
\newunicodechar{Λ}{\Lambda}
\newunicodechar{Θ}{\Theta}
\newunicodechar{Φ}{\Phi} % Digr F*
\newunicodechar{Π}{\Pi}
\newunicodechar{Ψ}{\Psi} % digr Q*
\newunicodechar{Σ}{\Sigma} % digr S*
\newunicodechar{Ω}{\Omega} % digr W*
\newunicodechar{ℕ}{\N} % Digr NN 8469 nonstandard
\newunicodechar{ℤ}{\Z} % Digr ZZ 8484 nonstandard
\newunicodechar{∑}{\sum}
\newunicodechar{∏}{\prod}
\newunicodechar{∫}{\int}
\newunicodechar{∓}{\mp}
\newunicodechar{⌈}{\lceil} % Digr <7
\newunicodechar{⌉}{\rceil} % Digr >7
\newunicodechar{⌊}{\lfloor} % Digr 7<
\newunicodechar{⌋}{\rfloor} % Digr 7>
\newunicodechar{≅}{\cong} % Digr ?=
\newunicodechar{≡}{\equiv} % Digr 3=
\newunicodechar{◁}{\triangleleft} % Digr Tl
\newunicodechar{▷}{\triangleright} % Digr Tr
\newunicodechar{≤}{\le}
\newunicodechar{≥}{\ge}
\newunicodechar{≪}{\ll} % Digr <*
\newunicodechar{≫}{\gg} % Digr *>
\newunicodechar{≠}{\ne}
\newunicodechar{⊆}{\subseteq} % Digr (_
\newunicodechar{⊇}{\supseteq} % Digr _)
\newunicodechar{⊂}{\subset} % Digr (C
\newunicodechar{⊃}{\supset} % Digr C)
\newunicodechar{∩}{\cap} % Digr (U
\newunicodechar{∖}{\setminus} % Digr -\ 8726 nonstandard
\newunicodechar{∪}{\cup} % Digr )U
\newunicodechar{∼}{\sim} % Digr ?1
\newunicodechar{≈}{\approx} % Digr ?2
\newunicodechar{∈}{\in} % Digr (-
\newunicodechar{∋}{\ni} % Digr -)
\newunicodechar{∇}{\nabla} % Digr NB
\newunicodechar{∃}{\exists} % Digr TE
\newunicodechar{∀}{\forall} % Digr FA
\newunicodechar{∧}{\wedge} % Digr AN
\newunicodechar{∨}{\vee} % Digr OR
\newunicodechar{⊥}{\bot} % Digr -T
\newunicodechar{⊢}{\vdash} % Digr \- 8866 nonstandard
\newunicodechar{⊨}{\models} % Digr \= 8872 nonstandard
\newunicodechar{⊤}{\top} % Digr TO 8868 nonstandard
\newunicodechar{⇒}{\implies} % Digr =>
\newunicodechar{⊸}{\multimap} % Digr #> nonstandard
\newunicodechar{⇐}{\impliedby} % Digr <=
\newunicodechar{⇔}{\iff} % Digr ==
\newunicodechar{↔}{\leftrightarrow} % Digr <>
\newunicodechar{↦}{\mapsto} % Digr T> 8614 nonstandard
\newunicodechar{∘}{\circ} % Digr Ob
\newunicodechar{⊕}{\oplus} % Digr O+ 8853
\newunicodechar{⊗}{\otimes} % Digr OX 8855
\newunicodechar{⟦}{\llbracket} % Digr [[ 10214 nonstandard (needs pkg stmaryrd)
\newunicodechar{⟧}{\rrbracket} % Digr ]] 10215 nonstandard


% cursed
\WarningFilter{newunicodechar}{Redefining Unicode}
\newunicodechar{·}{\ifmmode\cdot\else\textperiodcentered\fi} % Digr .M
\newunicodechar{×}{\ifmmode\times\else\texttimes\fi} % Digr *X
\newunicodechar{→}{\ifmmode\rightarrow\else\textrightarrow\fi} % Digr ->
\newunicodechar{←}{\ifmmode\leftarrow\else\textleftarrow\fi} % Digr ->
\newunicodechar{⟨}{\ifmmode\langle\else\textlangle\fi} % Digr LA 10216 nonstandard
\newunicodechar{⟩}{\ifmmode\rangle\else\textrangle\fi} % Digr RA 10217 nonstandard
\newunicodechar{…}{\ifmmode\dots\else\textellipsis\fi} % Digr .,
\newunicodechar{±}{\ifmmode\pm\else\textpm\fi} % Digr +-
\newunicodechar{¬}{\ifmmode\lnot\else\textlnot\fi} % Digr NO

\begin{document}

\maketitle

\chapter{Introduction}
A programming language needs to be more than just a lambda calculus,
capable only of functional abstraction and evaluation of expressions.
Programs need to have an effect on the outside world and, thinking more locally,
in our programs we would like to have fragments which do not merely reduce to a value in isolation,
but affect the execution of surrounding code in interesting ways.
This is what we call computational effects, the typical examples of which are:
input/output, mutable state, exceptions, nondeterminism, and coroutines.

Today, we are at the mercy of programming language designers to include the
effects we would like to use and make sure that they all interact with
each other well.
In recent years, however, a new approach, called \textit{algebraic effects}, has emerged.
Algebraic effects allow programmers to express all the usual computational effects as library code
and use them in the usual direct style (as opposed to eg. monadic encodings,
which do not always play well with the rest of the language and do not compose easily).
These implementations of effects are instances of one concept and hence interact
with each other predictably.

More concretely, algebraic effects may be thought of as resumable exceptions.
We can \textit{perform} an \textit{operation},
just as we can raise an exception in a typical high-level programming language.
The operation is then handled by the nearest enclosing \textit{handler} for the specific operation.
The handler receives the value given at perform-point and also,
unlike normal exception handlers,
a \textit{continuation}, a first-class functional value representing the rest
of the code to execute inside the handler from the perform-point.
By calling the continuation with a value we can resume at the perform-point,
as if performing the operation evaluated to the value.
But more interestingly, we can resume multiple times, or never, or store the continuation for later use.

This access to the continuation, while powerful, might also be a recipe for disaster.
That is why languages with algebraic effects typically have
\textit{type-and-effect systems},
not only tracking the type of value an expression might evaluate to, but also
what kind of effects it may perform on the way.

This work will study a particular formal language equipped with algebraic effects.
Although most results in the domain of programming languages depend crucially on the exact calculus and type system used,
we hope that the results, ideas, and techniques may apply elsewhere.
This should not seem far-fetched,
as the paper which introduced the language \cite{fscd19} is exactly about
interexpressibility with other systems.

Possibly the most interesting result of this work is a potentially novel use of coinduction
in the method of logical relations.
It allowed us to get rid of step-indexing in the definition of the logical relation and
ultimately prove termination of the language.
This may seem surprising, as coinduction is connotated primarily with infinite processes.

[todo other contributions]

I would like to thank Dariusz Biernacki, Filip Sieczkowski, and Piotr Polesiuk
for their help with this work.

\chapter{The language}
% TODO name the language?

We will study the deep handler calculus and type-and-effect system formulated
in \cite{fscd19}.
It is a refreshingly minimal language---the call-by-value lambda calculus with a few extensions
to be able to express the essence of algebraic effects.
There is only one unnamed universal operation, performed $\Do v$.
To be able to simulate calculi with named effects (and more),
the \textit{lift} operator, written $\Lift{e}$, is introduced.
When operations are performed inside the expression $e$ enclosed by lift,
the nearest handler will be skipped and the operation will be handled by the next one instead.
Naturally, the operator composes, so multiple enclosing lifts means multiple handlers skipped.
In contrast to most work on algebraic effects, the effect-tracking system here is structural,
we do not have any concept of predefined or user-defined (named) signatures of effects.
Finally, the language features polymorphic expressions and polymorphic operations.

\begin{figure}
\begin{align*}
	\textrm{TVar} ∋ α,β,…       &                    \\%&\textrm{(type variables)}\\
	\textrm{Var} ∋ f,r,x,y,…    &                    \\%&\textrm{(variables)}\\
	\textrm{Kind} ∋ κ           &::=
		\kT │ \kE │ \kR \\%&\textrm{(kinds)}\\
	\textrm{Typelike} ∋ σ,τ,ε,ρ &::=
		α │ τ→_ρτ │ ∀α::κ.\,τ │ ι │ ε · ρ
		\\%&\textrm{(types and rows)}\\
	\textrm{Val} ∋ v,u          &::= x │ λ x .\,t \\%&\textrm{(values)}\\
	\textrm{Exp} ∋ e            &::=
		v │ e\;e │ \Lift{e} │ \Do v │ \Handle e\,\{x,r.\,e;\,x.\,e\}
		\\%&\textrm{(expressions)}\\
	\textrm{ECont} ∋ K          &::=
		□ │ K\;e │ v\;K │ \Lift{K} │ \Handle K\,\{x,r.\,e;\,x.\,e\}
		\\%&\textrm{(evaluation contexts)}
\end{align*}
\caption{Syntax.}
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule
		{ }
		{0\Free(□)}

	\inferrule
		{n\Free(K)}
		{n\Free(K\;e)}

	\inferrule
		{n\Free(K)}
		{n\Free(v\;K)}

	\inferrule
		{n\Free(K)}
		{{n+1}\Free(\Lift{K})}

	\inferrule
		{{n+1}\Free(K)}
		{n\Free(\Handle K\,\{x,r.\,e_h;\,x.\,e_r\})}
\end{mathpar}
\caption{Evaluation context freeness.}
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule
		{e_1 ↦ e_2}
		{K[e_1] → K[e_2]}

	(λx.\,e)\;v ↦ e\subst{v}{x} % SUBST

	\Lift{v} ↦ v

	\inferrule
		{0\Free(K) \\ v_c = λz.\,\Handle K[z]\,\{x,r.\,e_h;\,x.\,e_r\}}
		{\Handle K[\Do v]\,\{x, r.\,e_h;\,x.\,e_r\} ↦ e_h\subst{v}{x}\subst{v_c}{r}} % SUBST

	\Handle v\,\{x,r.\,e_h;\,x.\,e_r\} ↦ e_r\subst{v}{x} % SUBST
\end{mathpar}
\caption{Single-step reduction.} % TODO "Contraction"???
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule
		{α ∷ κ ∈ Δ}
		{Δ ⊢ α ∷ κ}

	\inferrule
		{Δ ⊢ τ_1 ∷ \kT \\ Δ ⊢ ρ ∷ \kR \\ Δ ⊢ τ_2 ∷ \kT}
		{Δ ⊢ τ_1 →_ρ τ_2 ∷ \kT}

	\inferrule
		{Δ, α :: κ ⊢ τ ∷ \kT}
		{Δ ⊢ ∀α::κ.\, τ ∷ \kT}

	\inferrule
		{ }
		{Δ ⊢ ι ∷ \kR}

	\inferrule
		{Δ ⊢ ε ∷ \kE \\ Δ ⊢ ρ ∷ \kR}
		{Δ ⊢ ε · ρ ∷ \kR}

	\inferrule
		{Δ,Δ' ⊢ τ_1 ∷ \kT \\ Δ,Δ' ⊢ τ_2 ∷ \kT}
		{Δ ⊢ Δ'.\, τ_1 \Rightarrow τ_2 ∷ \kE}

	Δ ⊢ δ ∷ Δ' ⇔ \dom(δ) = \dom(Δ') ∧ ∀α∈\dom(δ).\, Δ ⊢ δ(α) ∷ Δ'(α)
\end{mathpar}
\caption{Well-formedness of types, rows, and type substitution.}
%TODO: inductive definition of well-formed type substitutions?
%TODO: syntax of Γ and Δ
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule
		{ }
		{Δ ⊢ σ <: σ}
		%\textsc{(S-Refl)}

	\inferrule
		{Δ ⊢ τ_2^1 <: τ_1^1 \\ Δ ⊢ ρ_1 <: ρ_2 \\ Δ ⊢ τ_1^2 <: τ_2^2}
		{Δ ⊢ τ_1^1 →_{ρ_1} τ_1^2 <: τ_2^1 →_{ρ_2} τ_2^2}
		%\textsc{(S-Arrow)}

	\inferrule
		{Δ, α ∷ κ ⊢ τ_1 <: τ_2}
		{Δ ⊢ ∀α∷κ.\, τ_1 <: ∀α∷κ. \,τ_2}
		%\textsc{(S-ForAll)}

	\inferrule
		{Δ ⊢ ρ ∷ \kR}
		{Δ ⊢ ι <: ρ}
		%\textsc{(S-Empty)}

	\inferrule
		{Δ ⊢ ρ_1 <: ρ_2}
		{Δ ⊢ ε·ρ_1 <: ε·ρ_2}
		%\textsc{(S-Extend)}
\end{mathpar}
\caption{Subtyping.}
\end{figure}

\begin{figure}
\begin{mathpar}
	\inferrule
		{x : τ ∈ Γ}
		{Δ;Γ ⊢ x : τ ╱ ι}

	\inferrule
		{Δ ⊢ τ_1 ∷ \kT \\ Δ;Γ, x:τ_1 ⊢ e : τ_2 ╱ ρ}
		{Δ;Γ ⊢ λx.\,e : τ_1 →_ρ τ_2 ╱ ι}

	\inferrule
		{Δ;Γ ⊢ e_1 : τ_1 →_ρ τ_2 ╱ ρ \\ Δ;Γ ⊢ e_2 : τ_1 ╱ ρ}
		{Δ;Γ ⊢ e_1\,e_2 : τ_2 ╱ ρ}

	\inferrule
		{Δ ⊢ ε ∷ \kE \\ Δ;Γ ⊢ e : τ ╱ ρ}
		{Δ;Γ ⊢ \Lift{e} : τ ╱ ε·ρ}

	\inferrule
		{Δ,α∷κ;Γ ⊢ e : τ ╱ ι}
		{Δ;Γ ⊢ e : ∀α∷κ.\,τ ╱ ι}

	\inferrule
		{Δ ⊢ σ ∷ κ \\ Δ;Γ ⊢ e : ∀α∷κ.\, τ ╱ ρ}
		{Δ;Γ ⊢ e : τ\subst{σ}{α} ╱ ρ}

	\inferrule
		{Δ ⊢ τ_1 <: τ_2 \\ Δ ⊢ ρ_1 <: ρ_2 \\ Δ;Γ ⊢ e : τ_1 ╱ ρ_1}
		{Δ;Γ ⊢ e : τ_2 ╱ ρ_2}

	\inferrule
		{Δ;Γ ⊢ v : δ(τ_1) ╱ ι \\ Δ ⊢ δ ∷ Δ' \\ Δ ⊢ Δ'.\, τ_1 \Rightarrow τ_2 ∷ \kE}
		{Δ;Γ ⊢ \Do v : δ(τ_2) ╱ (Δ'.\, τ_1 \Rightarrow τ_2)}

	\inferrule
		{Δ,Δ';Γ,x:τ_1,r:τ_2→_ρ τ_r ⊢ e_h : τ_r ╱ ρ \\ Δ;Γ, x:τ ⊢ e_r : τ_r ╱ ρ}
		{Δ;Γ ⊢ \Handle e\;\{x,r.\,e_h;x.\,e_r\} : τ_r ╱ ρ}

\end{mathpar}
\caption{Type system.}
\end{figure}

% TODO effect / row slash spacing macro  ╱


\chapter{The logical relation}
The logical relation is adapted from \cite{hwc} with a few changes:
our relation is unary, we additionally have polymorphic effects, we do not have type lambdas.

\section{Definition}

First, we define the spaces of \textit{semantic types} and \textit{semantic effects},
which are also the interpretations of the appropriate kinds:
\begin{align*}
	⟦\kT⟧ &= \mathcal{P}(\textrm{Val}) = \mathsf{Type},\\
	⟦\kE⟧=⟦\kR⟧ &= \mathcal{P}(\textrm{Exp}×ℕ×\mathsf{Type}) = \mathsf{Eff}.
\end{align*}
Semantic types are simply sets of closed values.
Semantic effects are sets of triples, which aim to describe a situation
in which an expression being evaluated performs an effect.
The components of such a triple are:
the argument of the operation,
the freeness of the enclosing context beyond which the operation can be handled,
and the semantic type of values we can call the resumption with.

Logical relations can be used to establish various properties.
Here, we choose termination to a value as our \textit{observation}:
% TODO: "good"
\begin{align*}
	\Obs = \{ e \mid ∃v.\, e →^* v \}.
\end{align*}

We start with defining interpretations of types and effects.
We parameterize the definitions by a mapping $η$ from type variables to
semantic types or effects.
\begin{align*}
	%⟦τ_1 →_ρ τ_2⟧_η
	%&= \{ t \mid ∀v∈⟦τ_1⟧.\, t\,v ∈ \E⟦τ_2/ρ⟧_η \} \\
	⟦τ_1 →_ρ τ_2⟧_η
	 &= \{ λx.\,e \mid ∀v∈⟦τ_1⟧_η.\, e\subst{v}{x} ∈ \E⟦τ_2/ρ⟧_η \} \\
	⟦∀α::κ.\,τ⟧_η
	&= \{ v \mid ∀μ∈⟦κ⟧.\, v ∈ ⟦τ⟧_{[α↦μ]η} \} \\
	⟦α⟧_η &= \{ v \mid ∀K.\, (∀u∈η(α).\, K[u]∈\Obs) ⇒ K[v]∈\Obs \} \\
	\\
	⟦τ_1 \Rightarrow τ_2⟧_η &= \{(v,0,⟦τ_2⟧_η) \mid v∈⟦τ_1⟧_η \} \\
	⟦∀α::κ.\,ε⟧_η &= \{t \mid ∃μ∈⟦κ⟧.\, t∈⟦ε⟧_{[α↦μ]η} \} \\
	⟦ε · ρ⟧_η &= ⟦ε⟧_η ∪ \{(v, n+1, μ) \mid (v, n, μ)∈⟦ρ⟧_η \} \\
	⟦ι⟧_η &= ∅
\end{align*}

By adapting the definitions from \cite{hwc} we end up with the following equations
we wish to hold
defining the sets of good expressions, contexts, and control-stuck terms:
\begin{align*}
	\E⟦τ/ρ⟧_η &=
	\{ e \mid ∀K∈\K⟦τ/ρ⟧_η.\, K[e] ∈ \Obs \} \\
	\K⟦τ/ρ⟧_η &=
	\{ K \mid ∀v∈ ⟦τ⟧_η.\, K[v] ∈ \Obs ∧ ∀s∈\S⟦τ/ρ⟧_η.\, K[s] ∈ \Obs\} \\
	\S⟦τ/ρ⟧_η &=
	\{ K[\Do v] \mid ∃n,μ.\, (v,n,μ)∈⟦ρ⟧_η ∧ n\Free(K) ∧ ∀u∈μ.\, K[u]∈\E⟦τ/ρ⟧_η\}
\end{align*}
This, however, does not immediately define anything yet,
due to the recursive occurence of $\E⟦τ/ρ⟧_η$.


\iffalse
\begin{align*}
	\E⟦τ/ρ⟧_η\gr{(X)} &=
	\{ e \mid ∀K∈\K⟦τ/ρ⟧_η\gr{(X)}.\, K[e] ∈ \Obs \} \\
	\K⟦τ/ρ⟧_η\gr{(X)} &=
	\{ K \mid ∀v∈ ⟦τ⟧ _η.\, K[v] ∈ \Obs ∧ ∀s∈\S⟦τ/ρ⟧_η\gr{(X)}.\, K[s] ∈ \Obs\} \\
	\S⟦τ/ρ⟧_η\gr{(X)} &=
	\{ K[\Do v] \mid ∃n,μ.\, (v,n,μ)∈⟦ρ⟧_η ∧ n\Free(K) ∧ ∀u∈μ.\, K[u]∈\gr{X}\}
\end{align*}
\fi

We untangle the recursion firstly by abstracting out the recursive occurence as an additional parameter
and secondly by noticing that we do not need the exact interpretations of types and effects,
any semantic type and effect will do.
\begin{align*}
	\E(μ,ξ)(X) &=
	\{ e \mid ∀K∈\K(μ,ξ)(X).\, K[e] ∈ \Obs \} \\
	\K(μ,ξ)(X) &=
	\{ K \mid ∀v∈μ.\, K[v] ∈ \Obs ∧ ∀s∈\S(μ,ξ)(X).\, K[s] ∈ \Obs\} \\
	\S(\_,ξ)(X) &=
	\{ K[\Do v] \mid ∃n,μ.\, (v,n,μ)∈ξ ∧ n\Free(K) ∧ ∀u∈μ.\, K[u]∈X\}
\end{align*}

We note that $\E(μ,ξ)$ is non-decreasing,
i.e. it is a monotone function on the complete lattice of the powerset of $\mathrm{Exp}$ ordered by inclusion.
Hence, by the Knaster-Tarski theorem, it has a greatest fixed point, % TODO cite
which we denote $ν\E(μ,ξ)$.
Moreover, the theorem states that it is specified by the following join:
% no consensus on pre/post ...
$$ν\E(μ,ξ) = \bigcup \{X ⊆ \mathrm{Exp} │ X ⊆ \E(μ,ξ)(X)\}.$$
%This is the argument $X$ we wanted, so we plug it in and set
%$\K(μ,ξ) = \K(μ,ξ,\E(μ,ξ))$ and
%$\S(μ,ξ) = \S(μ,ξ,\E(μ,ξ))$.

Now, it remains to plug in the interpretations of types as the semantic types:
\begin{align*}
\E⟦τ/ρ⟧_η &= ν\E(⟦τ⟧_η,⟦ρ⟧_η), \\
\K⟦τ/ρ⟧_η &= \K(⟦τ⟧_η,⟦ρ⟧_η)(\E⟦τ/ρ⟧_η), \\
\S⟦τ/ρ⟧_η &= \S(⟦τ⟧_η,⟦ρ⟧_η)(\E⟦τ/ρ⟧_η).
\end{align*}

Only now we can finally say that the interpretations of types and effects are defined by structural induction.
%(in the case of the arrow type
%we can treat $τ_2/ρ$ as a subterm of $τ_1 →_ρ τ_2$,
%just written in a different notation).

\section{Basic properties}
\begin{lemma}[Coinduction principle]\label{coinduction}
If $X ⊆ \E(μ,ξ)(X)$ then $X ⊆ ν\E(μ,ξ)$.
\end{lemma}
\begin{proof}
Follows directly from the definition.
\end{proof}

\begin{lemma}[Strong coinduction]\label{strong-coinduction}
	If $X ⊆ \E(μ,ξ)(X∪ν\E(μ,ξ))$, then $X ⊆ ν\E(μ,ξ)$.
\end{lemma}
\begin{proof}
	We have $ν\E(μ,ξ) = \E(μ,ξ)(ν\E(μ,ξ)) ⊆ \E(μ,ξ)(X∪ν\E(μ,ξ))$.
	Summing with the assumption we obtain
	$X∪ν\E(μ,ξ) ⊆ \E(μ,ξ)(X∪ν\E(μ,ξ))$, which is what we want by \cref{coinduction}.
\end{proof}
To reduce notational burden in proofs by strong coinduction,
we introduce the shorthand
$\E⟦τ/ρ⟧_η^{∪Y}$ to mean $\E(⟦τ⟧_η,⟦ρ⟧_η)(Y∪\E⟦τ/ρ⟧_η)$.
Similarly,
$\K⟦τ/ρ⟧_η^{∪Y}$ means $\K(⟦τ⟧_η,⟦ρ⟧_η)(Y∪\E⟦τ/ρ⟧_η)$ and
$\S⟦τ/ρ⟧_η^{∪Y}$ means $\S(⟦τ⟧_η,⟦ρ⟧_η)(Y∪\E⟦τ/ρ⟧_η)$.

\begin{lemma}
If $μ_1 ⊆ μ_2$ and $ξ_1 ⊆ ξ_2$,
then
\begin{align*}
\S(μ_1,ξ_1)(X) &⊆ \S(μ_2,ξ_2)(X), \\
\K(μ_1,ξ_1)(X) &⊇ \K(μ_2,ξ_2)(X), \\
\E(μ_1,ξ_1)(X) &⊆ \E(μ_2,ξ_2)(X).
\end{align*}
\end{lemma}

\begin{lemma}\label{monotonicity}
If $μ_1 ⊆ μ_2$ and $ξ_1 ⊆ ξ_2$, then $ν\E(μ_1,ξ_1) ⊆ ν\E(μ_2,ξ_2)$.
\end{lemma}
\begin{proof}
By \cref{monotonicity} and transitivity
if $μ_1 ⊆ μ_2$ and $ξ_1 ⊆ ξ_2$, then
$X ⊆ \E(μ_1,ξ_1)(X)$ implies $X ⊆ \E(μ_2,ξ_2)(X)$.
Therefore
$$\{X ⊆ \mathrm{Exp} │ X ⊆ \E(μ_1,ξ_1)(X)\}
⊆\{X ⊆ \mathrm{Exp} │ X ⊆ \E(μ_2,ξ_2)(X)\},$$
$$\bigcup \{X ⊆ \mathrm{Exp} │ X ⊆ \E(μ_1,ξ_1)(X)\}
⊆\bigcup \{X ⊆ \mathrm{Exp} │ X ⊆ \E(μ_2,ξ_2)(X)\}.$$
\end{proof}

\begin{lemma}\label{empty-context}
	For any semantic type $μ$ we have $□ ∈ \K(μ,∅)$.
\end{lemma}
\begin{proof}
	The set $\S(μ,∅)$ is empty and $μ$ is contained in $\Obs$.
\end{proof}

\begin{lemma}[Value inclusion]\label{value-inclusion}
	For any $τ$ and $ρ$ we have $⟦τ⟧_η ⊆ \E⟦τ/ρ⟧_η$.
\end{lemma}
\begin{proof}
	Follows from the definition of $\E⟦τ/ρ⟧_η$ and $\K⟦τ/ρ⟧_η$.
\end{proof}



\section{Compatibility lemmas}
We want to establish that $⊢ e : τ ╱ ι$ implies $e ∈ \E⟦τ/ι⟧$.
Termination to a value will follow from \cref{empty-context}.

For this purpose we will prove a semantic counterpart of each typing rule.
First, we need to define a counterpart to the typing judgment.
Unlike typing judgments, our relations are on closed terms only,
so we get around that by using substitution.
We define semantic entailment as
$$Δ;Γ ⊨ e : τ ╱ ρ ⇔ ∀η∈⟦Δ⟧.\, ∀γ∈⟦Γ⟧_η.\,γ(e) ∈ \E⟦τ/ρ⟧_η,$$
where $⟦Δ⟧ = \{ η │ ∀α∷κ∈Δ.\,η(α) ∈ ⟦κ⟧ \}$ contains type-level mappings
and $⟦Γ⟧_η = \{ γ │ ∀x:τ∈Γ.\,γ(x) ∈ ⟦τ⟧_η\}$ contains expression-level
variable substitutions.

\subsection{Lambda calculus core}

\begin{lemma}[Variable compatibility]
\end{lemma}
\begin{proof}
Assume $x : τ ∈ Γ$.
We want to prove $Δ;Γ ⊨ x : τ ╱ ι$.
Take any $η∈⟦Δ⟧$ and $γ∈⟦Γ⟧_η$.
We want to show $γ(x) ∈ \E⟦τ/ι⟧_η$.
From the definition of $⟦Γ⟧_η$
we know that $γ(x) ∈ ⟦τ⟧_η$,
so by \cref{value-inclusion} we have $γ(x) ∈ \E⟦τ/ι⟧_η$.
\end{proof}

\begin{lemma}[Abstraction compatibility]
\end{lemma}
\begin{proof}
Assume $Δ ⊢ τ_1 ∷ \kT$ and $Δ;Γ,x:τ_1 ⊨ e : τ_2 ╱ ρ$.
% Note: kind assumption necessary so that τ_1 →_ρ τ_2 well formed
We want to prove $Δ;Γ ⊨ λx.\,e : τ_1 →_ρ τ_2 ╱ ι$.
Take any $η∈⟦Δ⟧$ and $γ∈⟦Γ⟧_η$.
By \cref{value-inclusion} it suffices to show
$γ(λx.\,e) = λx. γ(e) ∈ ⟦τ_1 →_ρ τ_2⟧_η$.
So take any $v ∈ ⟦τ_1⟧_η.$
% TODO: use of arrow interpretation; fragile
We need to show $γ(e)\subst{v}{x} ∈ \E⟦τ_2/ρ⟧_η$.
Let $γ' = γ'[x↦v]$.
Then by $γ' ∈ ⟦Γ,x:τ_1⟧_η$, so $γ(e)\subst{v}{x} = γ'(e) ∈ \E⟦τ_2/ρ⟧_η.$
\end{proof}

\begin{lemma}[Application compatibility]
\end{lemma}
\begin{proof}
Assume $Δ;Γ ⊨ e_1 : τ_1 →_ρ τ_2 ╱ ρ$ and $Δ;Γ ⊨ e_2 : τ_1 ╱ ρ$.
We want to show $Δ;Γ ⊨ e_1\;e_2 : τ_2 ╱ ρ$.
Take any $η∈⟦Δ⟧$, $γ∈⟦Γ⟧_η$, and $K ∈ \K⟦τ_2/ρ⟧_η$.
We want $K[γ(e_1)\;γ(e_2)] ∈ \Obs$.
Let $K_1 = K[γ(e_1)\;□]$, then $K[γ(e_1)\;γ(e_2)] = K_1[γ(e_2)]$.
It suffices to show that $K_1 ∈ \K⟦τ_1/ρ⟧_η$.

Take any $e ∈ \S⟦τ_1/ρ⟧_η$.
We want $K_1[e] = K[γ(e_2)\;e] ∈ \Obs$.
Suffices to show that $γ(e_2)\;e ∈ \S⟦τ_2/ρ⟧_η$.
\end{proof}

\subsection{Effects}

\subsection{Subtyping}

\subsection{Polymorphism}

\bibliographystyle{plain}
\bibliography{refs}

\end{document}

\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{silence}
\usepackage{parskip}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{newunicodechar}
\usepackage{etoolbox}
\usepackage[margin=1.2in]{geometry}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{stmaryrd}
\usepackage{microtype}
\usepackage[dvipsnames]{xcolor}
\setcounter{secnumdepth}{0}

\title{Polymorphic algebraic effects: theoretical properties and implementation}
\author{Wiktor Kuchta}
\date{\vspace{-4ex}}

\newcommand{\Do}{\textsf{do\,}}
\newcommand{\Free}{\textrm{-}\mathrm{free}}
\newcommand{\Obs}{\mathrm{Obs}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\modulus}[1]{\left| #1 \right|}
\newcommand{\abs}{\modulus}
\newcommand{\ol}{\overline}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\diag}{diag}
\newcommand{\+}{\enspace}
\newcommand{\gr}{\textcolor{ForestGreen}}

\newunicodechar{∅}{\emptyset} % Digr /0
\newunicodechar{∞}{\infty} % Digr 00
\newunicodechar{∂}{\partial} % Digr dP
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{ξ}{\xi} % Digr c*
\newunicodechar{δ}{\delta} % Digr d*
\newunicodechar{ε}{\varepsilon}
\newunicodechar{φ}{\varphi}
\newunicodechar{θ}{\theta} % Digr h*
\newunicodechar{κ}{\kappa}
\newunicodechar{λ}{\lambda}
\newunicodechar{μ}{\mu}
\newunicodechar{π}{\pi}
\newunicodechar{ψ}{\psi}
\newunicodechar{ρ}{\rho}
\newunicodechar{σ}{\sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{ω}{\omega}
\newunicodechar{η}{\eta} % Digr y*
\newunicodechar{ζ}{\zeta} % Digr z*
\newunicodechar{Δ}{\Delta}
\newunicodechar{Γ}{\Gamma}
\newunicodechar{Λ}{\Lambda}
\newunicodechar{Θ}{\Theta}
\newunicodechar{Φ}{\Phi} % Digr F*
\newunicodechar{Π}{\Pi}
\newunicodechar{Ψ}{\Psi} % digr Q*
\newunicodechar{Σ}{\Sigma} % digr S*
\newunicodechar{Ω}{\Omega} % digr W*
\newunicodechar{ℕ}{\N} % Digr NN 8469 nonstandard
\newunicodechar{ℤ}{\Z} % Digr ZZ 8484 nonstandard
\newunicodechar{∑}{\sum}
\newunicodechar{∏}{\prod}
\newunicodechar{∫}{\int}
\newunicodechar{∓}{\mp}
\newunicodechar{⌈}{\lceil} % Digr <7
\newunicodechar{⌉}{\rceil} % Digr >7
\newunicodechar{⌊}{\lfloor} % Digr 7<
\newunicodechar{⌋}{\rfloor} % Digr 7>
\newunicodechar{≅}{\cong} % Digr ?=
\newunicodechar{≡}{\equiv} % Digr 3=
\newunicodechar{◁}{\triangleleft} % Digr Tl
\newunicodechar{▷}{\triangleright} % Digr Tr
\newunicodechar{≤}{\le}
\newunicodechar{≥}{\ge}
\newunicodechar{≪}{\ll} % Digr <*
\newunicodechar{≫}{\gg} % Digr *>
\newunicodechar{≠}{\ne}
\newunicodechar{⊆}{\subseteq} % Digr (_
\newunicodechar{⊇}{\supseteq} % Digr _)
\newunicodechar{⊂}{\subset} % Digr (C
\newunicodechar{⊃}{\supset} % Digr C)
\newunicodechar{∩}{\cap} % Digr (U
\newunicodechar{∖}{\setminus} % Digr -\ 8726 nonstandard
\newunicodechar{∪}{\cup} % Digr )U
\newunicodechar{∼}{\sim} % Digr ?1
\newunicodechar{≈}{\approx} % Digr ?2
\newunicodechar{∈}{\in} % Digr (-
\newunicodechar{∋}{\ni} % Digr -)
\newunicodechar{∇}{\nabla} % Digr NB
\newunicodechar{∃}{\exists} % Digr TE
\newunicodechar{∀}{\forall} % Digr FA
\newunicodechar{∧}{\wedge} % Digr AN
\newunicodechar{∨}{\vee} % Digr OR
\newunicodechar{⊥}{\bot} % Digr -T
\newunicodechar{⊢}{\vdash} % Digr \- 8866 nonstandard
\newunicodechar{⊨}{\models} % Digr \= 8872 nonstandard
\newunicodechar{⊤}{\top} % Digr TO 8868 nonstandard
\newunicodechar{⇒}{\implies} % Digr =>
\newunicodechar{⊸}{\multimap} % Digr #> nonstandard
\newunicodechar{⇐}{\impliedby} % Digr <=
\newunicodechar{⇔}{\iff} % Digr ==
\newunicodechar{↔}{\leftrightarrow} % Digr <>
\newunicodechar{↦}{\mapsto} % Digr T> 8614 nonstandard
\newunicodechar{∘}{\circ} % Digr Ob
\newunicodechar{⊕}{\oplus} % Digr O+ 8853
\newunicodechar{⊗}{\otimes} % Digr OX 8855
\newunicodechar{⟦}{\llbracket} % Digr [[ 10214 nonstandard (needs pkg stmaryrd)
\newunicodechar{⟧}{\rrbracket} % Digr ]] 10215 nonstandard


% cursed
\WarningFilter{newunicodechar}{Redefining Unicode}
\newunicodechar{·}{\ifmmode\cdot\else\textperiodcentered\fi} % Digr .M
\newunicodechar{×}{\ifmmode\times\else\texttimes\fi} % Digr *X
\newunicodechar{→}{\ifmmode\rightarrow\else\textrightarrow\fi} % Digr ->
\newunicodechar{←}{\ifmmode\leftarrow\else\textleftarrow\fi} % Digr ->
\newunicodechar{⟨}{\ifmmode\langle\else\textlangle\fi} % Digr LA 10216 nonstandard
\newunicodechar{⟩}{\ifmmode\rangle\else\textrangle\fi} % Digr RA 10217 nonstandard
\newunicodechar{…}{\ifmmode\dots\else\textellipsis\fi} % Digr .,
\newunicodechar{±}{\ifmmode\pm\else\textpm\fi} % Digr +-
\newunicodechar{¬}{\ifmmode\lnot\else\textlnot\fi} % Digr NO

\begin{document}

\maketitle

\chapter{Introduction}
A programming language needs to be more than just a lambda calculus,
capable only of functional abstraction and evaluation of expressions.
Programs need to have an effect on the outside world and, thinking more locally,
in our programs we would like to have fragments which do not merely reduce to a value in isolation,
but affect the execution of surrounding code in interesting ways.
This is what we call computational effects, the typical examples of which are:
input/output, mutable state, exceptions, nondeterminism, and coroutines.

Today, we are at the mercy of programming language designers to include the
effects we would like to use and make sure that they all interact with
each other well.
In recent years, however, a new approach, called \textit{algebraic effects}, has emerged.
Algebraic effects allow programmers to express all the usual computational effects as library code
and use them in the usual direct style (as opposed to eg. monadic encodings,
which do not always play well with the rest of the language and do not compose easily).
These implementations of effects are instances of one concept and hence interact
with each other predictably.

More concretely, algebraic effects may be thought of as resumable exceptions.
We can \textit{perform} an \textit{operation},
just as we can raise an exception in a typical high-level programming language.
The operation is then handled by the nearest enclosing \textit{handler} for the specific operation.
The handler receives the value given at perform-point and also,
unlike normal exception handlers,
a \textit{continuation}, a first-class functional value representing the rest
of the code to execute inside the handler from the perform-point.
By calling the continuation with a value we can resume at the perform-point,
as if performing the operation evaluated to the value.
But more interestingly, we can resume multiple times, or never, or store the continuation for later use.

This access to the continuation, while powerful, might also be a recipe for disaster.
That is why languages with algebraic effects typically have
\textit{type-and-effect systems},
not only tracking the type of value an expression might evaluate to, but also
what kind of effects it may perform on the way.

[todo segue]

We will study the deep handler calculus and type-and-effect system formulated
in \cite{fscd19}.
It is a refreshingly minimal language---the call-by-value lambda calculus with a few extensions
to be able to express the essence of algebraic effects.
There is only one unnamed universal operation, written $\Do v$.
To be able to simulate calculi with named effects (and more),
the \textit{lift} operator, written $[e]$, is introduced.
When performing operations in code enclosed by lift,
the nearest handler will be skipped and the operation will be handled by the next one instead.
Naturally, the operator composes, so multiple enclosing lifts means multiple handlers skipped.
Interestingly, the effect-tracking system is structural,
we do not have any concept of predefined or user-defined (named) signatures of effects.
Finally, the language includes polymorphic expressions and polymorphic operations.

\chapter{The logical relation}
The logical relation is adapted from \cite{hwc} with a few changes:
our relation is unary, we additionally have polymorphic effects, we do not have type lambdas.

\begin{align*}
	⟦\mathsf{T}⟧ &= \mathcal{P}(\mathsf{Val}) = \mathsf{Type}\\
	⟦\mathsf{E}⟧=⟦\mathsf{R}⟧ &= \mathcal{P}(\mathsf{Exp}×ℕ×\mathsf{Type}) = \mathsf{Eff}\\
\end{align*}

\begin{align*}
	\Obs = \{ e \mid ∃v.\, e →^* v \}
\end{align*}

% typing ???

\begin{align*}
	\mathcal{E}⟦τ/ρ⟧_η &=
	\{ t \mid ∀K∈\mathcal{K}⟦τ/ρ⟧_η.\, K[t] ∈ \Obs \} \\
	\mathcal{K}⟦τ/ρ⟧_η &=
	\{ K \mid ∀v∈ ⟦τ⟧ _η.\, K[v] ∈ \Obs ∧ ∀s∈\mathcal{S}⟦τ/ρ⟧_η.\, K[s] ∈ \Obs\} \\
	\mathcal{S}⟦τ/ρ⟧_η &=
	\{ K[\Do v] \mid ∃n,μ.\, (v,n,μ)∈⟦ρ⟧_η ∧ n\Free(K) ∧ ∀e∈μ.\, K[e]∈\mathcal{E}⟦τ/ρ⟧_η\} \\
\end{align*}
%
\begin{align*}
	%⟦τ_1 →_ρ τ_2⟧_η
	%&= \{ t \mid ∀v∈⟦τ_1⟧.\, t\,v ∈ \mathcal{E}⟦τ_2/ρ⟧_η \} \\
	⟦τ_1 →_ρ τ_2⟧_η
	&= \{ λx.\,t \mid ∀v∈⟦τ_1⟧.\, [x↦v]t ∈ \mathcal{E}⟦τ_2/ρ⟧_η \} \\
	⟦∀α::κ.\,τ⟧_η
	&= \{ v \mid ∀μ∈⟦κ⟧.\, v ∈ ⟦τ⟧_{[α↦μ]η} \} \\
	⟦α⟧_η &= \{ v \mid ∀K. (∀u∈η(α). K[u]∈\Obs) ⇒ K[v]∈\Obs \} \\
	\\
	⟦τ_1 \Rightarrow τ_2⟧_η &= \{(v,0,⟦τ_2⟧_η) \mid v∈⟦τ_1⟧_η \} \\
	⟦∀α::κ.\,ε⟧_η &= \{t \mid ∃μ∈⟦κ⟧.\, t∈⟦ε⟧_{[α↦μ]η} \} \\
	⟦ε · ρ⟧_η &= ⟦ε⟧_η ∪ \{(v, n+1, μ) \mid (v, n, μ)∈⟦ρ⟧_η \}
\end{align*}

\begin{align*}
	\mathcal{E}⟦τ/ρ⟧_η\gr{(X)} &=
	\{ t \mid ∀K∈\mathcal{K}⟦τ/ρ⟧_η\gr{(X)}.\, K[t] ∈ \Obs \} \\
	\mathcal{K}⟦τ/ρ⟧_η\gr{(X)} &=
	\{ K \mid ∀v∈ ⟦τ⟧ _η.\, K[v] ∈ \Obs ∧ ∀s∈\mathcal{S}⟦τ/ρ⟧_η\gr{(X)}.\, K[s] ∈ \Obs\} \\
	\mathcal{S}⟦τ/ρ⟧_η\gr{(X)} &=
	\{ K[\Do v] \mid ∃n,μ.\, (v,n,μ)∈⟦ρ⟧_η ∧ n\Free(K) ∧ ∀e∈μ.\, K[e]∈\gr{X}\}
\end{align*}

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
